&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2026-01-08 15:11:14  

- [connect](#connect)
- [labmda](#labmda)

# connect
- 怎么说呢, 但是不是成员函数, 而是`Qt`提供的通用函数. 思想也是非常简单. 当然, `qt`内部有专有名词, 但是我不太愿意用, 我就用自己的名词来说吧. 
- 我觉得呢, `qt`绑定的是两个对象之间的联系. 为什么会绑定两个对象呢? 在嵌入式中, 我确实是遇到过类似的问题. 从面向对象角度来看, 每个对象都是有自己的生命周期的. 想要调用, 就必须得实例化. 比如按键`key`, 在`C`中, 我们不用考虑其它问题, 因为函数几乎都是全局函数, 随时调用. 但是, 如果是`C++`的话, 我们将`key`抽象成类的话, 那么调用其方法就必须先实例化一个`key`对象. 
- 比如, 我想让`key`跟`led`绑定, 就是按下`key`, 小灯亮. 我想将小灯的动作, 完全地封装到某个函数中. 但是, 这个函数如果是其成员对象的话, 调用起来就很不灵活, 无法达到理想的情况. 
- 为什么呢? `c++`作为编译型语言, 变量类型至关重要, 并不像`python`一样, 想怎么传入都行. 我最后是通过静态对象调用成员函数的方法解决的. 
- 虽然解决了, 但是参数传递还存在问题. 我必须得为不同数量的参数函数指针, 而重载不同的`key`成员函数.
- 总而言之, 我自己的方法确实存在问题, 当时也没有找到更合适的方法, 只能这么勉强来用. 
- 看到`qt`的`connect`之后, 恍然大悟. 设计的非常好, 很值得参考借鉴. 虽然并不知道怎么实现的, 但确实是做到了解耦, 并且也避免了静态对象的存在. 
- 被骗了. `connect`不是全局函数. 是`Q_Object`的成员函数. 坏了, 被骗了啊, 哈哈. 那么上面的看看就好. 
- 好了, 下面的`lambda`原理写完了. 在下面的基础上, 感觉对于`connect`的实现, 又理解了一些. 
- 我觉得首先得逻辑闭环. 谁调用的谁, 怎么调用的, 如何实现的, 这几点都必须要清楚. 如果逻辑无法闭环, 那根本就理解不了, 这也怪不了谁, 哈哈. 
- `connect`, 确实是成员函数. 但是, 是静态成员函数. 所以没被骗, 可以全局调用. 
- 分析了一下, 逻辑确实闭环了. 我们中间层可以有很多个`connect`, 就是起到松耦合的目的. 思想确实确实确实很牛掰. 
- 怎么做到的呢? 
    - 我们先不考虑复杂情况, 就只单纯地考虑`A->B`这种情况. 其中, `A`是信号发出者, 我们称之为`signal`, `B`是信号接收者, 也就是槽(`slot`). 
    - 底层怎么实现的呢? 比如, `A`是`key`, `B`是`led`, `connect`调用可以是`connect(A, methodA, B, methodB)`. 切换成具体实例, 可以是`connect(key, on, led, toggle)`. 效果是什么呢? 当我按下按键, 小灯会反转. 在我看来, 实际上, 就是`key`的成员函数`on`, 传入了`led`的成员函数`toggle`, 并且在其内部调用了该方法. 
    - 按照之前说的, 如果通过参数传递实现的话, 会存在一定的耦合性. 但是, 通过中间函数`connect`来实现, 似乎可以松耦合(怎么松的呢? 也就是`connect`底层是如何实现的呢? 在我看来, 似乎还是要以参数的形式传入...)
    - 这里其实就完成了`A->B`的绑定. 
    - 如果是`A->B->C`, 那应该怎么办呢? 很简单, 两个`connect`就可以解决. 对于`B`而言, 它并不需要具体的实现, 只需要通过指针, 能传递即可. 但是`B`也有其存在的意义. 我们可以在其内部添加逻辑判断, 从而能正确传递. 
    - 对于这里的`B`而言, 它相对于`A`, 是槽, 而相对于`C`是信号. 也就是`connect(A, methodA, B, methodB)`, `connect(B, methodB, C, methodC)`, 就这么简单. 在实现第一个`connect`的时候, 可以通过`lambda`, 添加逻辑判断. 在第二个`connect`中, `methodC`就是具体的动作(逻辑实现), 而`methodB`就是信号作用. 
    - 这样来看, 就明确很多很多了. 后续写按键绑定的时候, 简单了很多很多. 哈哈, 还是理解更重要, 理解之后, 再刻意练习练习, 直接就无敌. 

# labmda
- 哎, 看了`ai`给出的`lambda`解释, 直接让我醍醐灌顶的, 简直太秒了. 懂了`c++`的`lambda`之后, 其它的像`lua`中的直接定义函数, `python`的`lambda`函数等的实现原理就明确清晰了很多, 只能说秒, 太妙了. 
- 我们一步一步的看. 

~~~cpp
int x = 10;

auto f = [x](int y) {
    return x + y;
};
~~~

- 假如, 我们定义了如上的`lambda`函数, 编译器实际上生成的是什么呢? `[]`中与`()`中传入的东西, 又有什么区别呢? 是否曾经考虑过呢? 
- 以前, 在`lua`, `python`, 它们的`lambda`, 都认为是函数. 但是`c++`里, 需要换一种眼光来看待. 上面的操作, 实际上就是相当于下面的东西.

~~~cpp
class __Lambda_1 {
    int x;              // 捕获的变量 → 成员变量
public:
    __Lambda_1(int x_) : x(x_) {}

    int operator()(int y) const {
        return x + y;
    }
};
~~~

- 怎么样, 竟然生成了一个类!
- 这里的`operator()`, 其实并不是在`c++`中理解的, 而是在`python`里面. 这里就是相当于`python`里面的`__call__()`. 什么意思呢? 就是当我们对对象, 调用`()`时, 就会直接调用这个函数, 也就是`int operator()`. 让对象像函数一样被调用. 
- `lambda`中的`[]`里面的参数, 其实就是构造函数里面的参数, 而`()`内部参数, 就是调用运算符`()`里面的参数. 这样就很明确了. 
- 以前, 我思考过, `python`想传入一个类对象, 直接传入即可, 可是`c++`怎么传入类对象呢? 类名能直接传入吗? 答案是否定的. 但是, 通过这里, 发现了其它的, 更有趣的实现方案, 确实不错. 

~~~cpp
int a = 10;

auto f1 = [a]() { return a; };
auto f2 = [](int a) { return a; };
~~~

- 所以, 再看上面的例子, 这俩`a`, 实际上不是同一个`a`, 这一点一定要明确. 
- 所以, 在理解上面的基础之上, 再去看`qt`的信号槽实现机理, 就明确了很多.








