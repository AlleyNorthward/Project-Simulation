&emsp;&emsp;@author 巷北  
&emsp;&emsp;@time 2026-01-04 11:15:34  

# 简介
&emsp;&emsp;很可惜, 昨天这里其实都写好了, 不过不小心被删除了. 怎么删除的呢? 昨天本来压缩了一份, 目的是发到群里, 大家一起看看. 今天早上打开的时候, 发现有个压缩包, 想都没想直接`rm`删除了. 但是, 这个压缩包跟项目包同名, 我是`tab`自动补全, 没看是压缩包名还是项目名, 直接确认删除了. 很可惜, 删除的是项目名. 由于昨天发到群里后, 又写了很多东西, 这些东西自然也就没有了. 当然, 也没提交到`git`备份一份, 哈哈. <br>
&emsp;&emsp;不过不用感到可惜, 可以重新写一份. 但这也确实敲响了警钟, 加入没有任何备份, 被删除了怎么办呢(当然, 考虑因果关系的话, 我不压缩发到群里, 自然也就不会`rm`删除). 所以, 还是应当及时更新的, 这是很有必要的. 写到这, 我先去`git`一下, 哈哈.<br>
&emsp;&emsp;那么, 我们就再来重写一遍吧. 由于昨天已经重写过了, 所以今天肯定也是轻车熟路. 废话也不会说太多. <br>

- [SqlConnection](#SqlConnection)
    - [_SqlConnection](#_SqlConnection)
    - [instance](#instance)
    - [open](#open)
    - [database](#database)
    - [close](#close)
    - [2026/01/04/13/12/21](#20260104131221)

## SqlConnection
### _SqlConnection
&emsp;&emsp;这个代表的是什么呢? 构造函数. 因为不能跟上级同名, 所以这里就做出了一定的改变, 就是添加了一个`_`, 用来代表构造函数 哈哈. <br>
&emsp;&emsp;整体思想呢, 非常简单, 就是通过`Uuid`, 创建一个`uid`, 并且赋给属性`connectionName`, 这样以后我们就可以轻松地找到这个数据库对象了. <br>
&emsp;&emsp;注意, 内部用了一些`QString`的方法, 简单说一下. `%1`是占位符, `arg`就是解该占位符的. 也就是说, 将`arg`内部的`QString`类型对象, 直接放到`%1`这个位置上. <br>

### instance
这个其实也是比较明确的. 这里用到了单例模式, 仔细仔细思考一下, 确实是必须存在的. `C++`的单例模式, 关键是有一个静态方法, 这样可以通过类名直接调用. 然后呢, 内部返回的是静态对象. 为了确保其唯一性, 需要私有化构造函数, 并且删除复制, 删除重载`=`这俩函数, 这样能保证其唯一性. 
确实很简单. 但是, 昨天写的时候, 发生了一个小问题, 就是返回类型问题. 在头文件定义的时候, 是下面形式的:

~~~c++
static _SqlConnection &instance();
~~~

因为之前弄指针的时候, 我自己强调是这么写:`int* p`, 而不是这么写:`int *p`, 主要原因就是, 我认为前者强调的是一个指针类型, 其次才是变量. 而后者的写法, 很容易让我认为`*`跟`p`是绑定在一起的. 但其实并不是, 只有取值的时候, 才需要`*p`去解引用. 
因为没有深入研究过引用相关的东西, 所以看到上面的写法, 我很自然的认为函数类型是`_SqlConnection`类型, 自然, 实现的时候, 并没有带上引用, 也就是下面的写法:

~~~c++
_SqlConnection _SqlConnection::instance()
~~~

也就很自然地报错了. 而且我自认为很对, 并没有错误, 哈哈. 后来才明白, 返回的是其引用类型, 改过来也就不再报错了. 
那么为什么我不将`&`跟返回类型贴在一块呢? 主要是因为用的`lsp`, 可以自动格式化, 我绑定了`快捷键<leader> f`, 按一下就格式化了. 没有办法, 哈哈. 

### open
&emsp;&emsp;`open()`的实现, 也是很简单. 我们先考虑从未创建的情况. <br>
&emsp;&emsp;首先, 需要实例化一个数据库对象, 也就是`QSqlDatabase`类型对象. 实例化也很简单, 通过`addDatabase()`获取. 内部需要参数是驱动类型, 以及链接名(`connectionName`, 也就是我们的属性). 这里的`addDatabase()`, 是通过类名获取的, 所以我觉得是个静态对象, 本质可能也是一个单例模式. <br>
&emsp;&emsp;然后呢, 我们的驱动是`ODBC`, 所以就很简单的, 只需要提供数据库名, 用户名, 密码, 就可以连接了. 但让, 我们需要判断`!db.open()`, 来确定是否打开.<br>
&emsp;&emsp;其实到这里就结束了. 但如果我们连接过, 又重复连接, 该怎么办呢? 此时也很简单, 就是通过`connectionName`, 来判断是否曾经连接过. 但是这个方法有些忘记了. 我记得是不是`database`直接获取呢? 忘记了, 哈哈. 先不管了, 去写写试试吧. <br>
&emsp;&emsp;基本没问题. 通过`contains()`判断是否创建过, 通过`database`获取已创建对象. <br>

### database
&emsp;&emsp;这个`database`, 其实也就是获取当前`QSqlDatabase`. 但是关键点并不在这里, 而是获取这个对象, 函数后面加了一个`const`, 什么意思呢?<br>
&emsp;&emsp;其实很简单, 就是保证, 这个函数内部, 不会修改该类的成员变量. 几乎所有的`get`函数, 都是这个`const`类型的. <br>
&emsp;&emsp;本质就相当于给`this`指针, 添加了一个`const`, 保证它不会改变. 类外的普通函数呢, 没有权利添加`const`, 因为它们没有对应的属性(或者`this`指针). <br>
&emsp;&emsp;但是, 除了这里有`const`, 我们还经常看见函数参数是带有`const`的. 这里其实就是约定, 保证函数中不会修改这个变量的值(只读的). 普通的变量倒也无所谓, 因为在栈上生成的临时变量, 函数用完这个变量也就释放了. 可如果是传入的变量引用, 那么就需要非常小心, 添加约定也就成了必须之举. 所以, 我们经常会看到, 函数参数, `const`跟`&`在一块, 例如下面情形:<br>

~~~c++
void test(const int& a, const int& b);
~~~

&emsp;&emsp;不过我们要明确, `const`函数参数, 不会强制要求你必须传入`const`类型变量. 非`const`也可以传入. 这只是一种约定, 向下兼容. 但是, `const`类型变量, 肯定无法传入非`const`函数参数中, 因为这个函数, 没有保证是否会改变这个类型变量, 所以为了安全, 编译期间会报错. <br>
&emsp;&emsp;明确了这一点, 其它的都好说了, 哈哈.<br>
&emsp;&emsp;这个函数呢, 也很简单, 判断是否存在, 存在返回该对象, 不存在返回空对象(构造函数, 确保安全). <br>
&emsp;&emsp;我自己写的时候呢, 还是判断了这个数据库是否打开了. 但其实没必要, 因为我只想获取这个对象, 而并不关起其是否连接. <br>

### close

&emsp;&emsp;最后剩下了`close` 这个确实很不一般. 原因也肯定讲不明白, 还是那句话, 知道就行. <br>

### 2026/01/04/13/12/21
&emsp;&emsp;当前的总结吧. 数据库连接这个写了几遍了, 已经有了自己的认识了. 当然, 后面还会有查询等等等等的, 这些都不是关键, 关键是还要对数据库有自己一定的理解才行, 没有数据库的理解, `Qt`端肯定也很难写好, 所以还是要多努力地学, 好吧. <br>












